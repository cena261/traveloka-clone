package com.cena.traveloka.iam.mapper;

import com.cena.traveloka.iam.dto.request.SessionCreateReq;
import com.cena.traveloka.iam.dto.response.ActiveSessionsRes;
import com.cena.traveloka.iam.dto.response.SessionRes;
import com.cena.traveloka.iam.entity.UserSession;
import org.mapstruct.*;

import java.time.Duration;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.stream.Collectors;

/**
 * MapStruct mapper for UserSession entity and DTOs
 */
@Mapper(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface SessionMapper {

    // === Entity to Response DTOs ===

    /**
     * Map UserSession entity to SessionRes DTO
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "userId", source = "userId")
    @Mapping(target = "sessionId", source = "sessionId")
    @Mapping(target = "ipAddress", source = "ipAddress")
    @Mapping(target = "userAgent", source = "userAgent")
    @Mapping(target = "deviceInfo", source = ".", qualifiedByName = "buildDeviceInfo")
    @Mapping(target = "status", source = "status")
    @Mapping(target = "sessionData", source = "metadata")
    @Mapping(target = "createdAt", source = "createdAt", qualifiedByName = "offsetDateTimeToInstant")
    @Mapping(target = "lastAccessedAt", source = "lastActivityAt", qualifiedByName = "offsetDateTimeToInstant")
    @Mapping(target = "expiresAt", source = "expiresAt", qualifiedByName = "offsetDateTimeToInstant")
    @Mapping(target = "terminatedAt", ignore = true) // Not in UserSession entity
    @Mapping(target = "terminationReason", ignore = true) // Not in UserSession entity
    @Mapping(target = "active", source = ".", qualifiedByName = "isActive")
    @Mapping(target = "durationMinutes", source = ".", qualifiedByName = "calculateDuration")
    SessionRes toSessionRes(UserSession session);

    /**
     * Map list of UserSession entities to list of SessionRes DTOs
     */
    List<SessionRes> toSessionResList(List<UserSession> sessions);

    /**
     * Map UserSession entity to ActiveSessionsRes.SessionSummaryRes
     */
    @Mapping(target = "sessionId", source = "sessionId")
    @Mapping(target = "deviceInfo", source = ".", qualifiedByName = "buildDeviceInfo")
    @Mapping(target = "ipAddress", source = "ipAddress")
    @Mapping(target = "lastAccessedAt", source = "lastActivityAt", qualifiedByName = "formatInstantFromOffsetDateTime")
    @Mapping(target = "current", ignore = true) // Set by service
    ActiveSessionsRes.SessionSummaryRes toSessionSummaryRes(UserSession session);

    /**
     * Map list of UserSession entities to ActiveSessionsRes
     */
    default ActiveSessionsRes toActiveSessionsRes(List<UserSession> sessions, String userId, String currentSessionId) {
        ActiveSessionsRes response = new ActiveSessionsRes();
        response.setUserId(userId);
        response.setTotalActiveSessions(sessions.size());
        response.setTotalAllowedSessions(5); // Default limit, could be configurable

        List<ActiveSessionsRes.SessionSummaryRes> sessionSummaries = sessions.stream()
                .map(this::toSessionSummaryRes)
                .collect(Collectors.toList());

        // Mark current session
        sessionSummaries.forEach(summary ->
            summary.setCurrent(summary.getSessionId().equals(currentSessionId))
        );

        response.setSessions(sessionSummaries);
        return response;
    }

    // === Request DTOs to Entity ===

    /**
     * Map SessionCreateReq DTO to UserSession entity
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", source = "userId")
    @Mapping(target = "sessionId", ignore = true) // GENERATED by service
    @Mapping(target = "ipAddress", source = "ipAddress")
    @Mapping(target = "userAgent", source = "userAgent")
    @Mapping(target = "metadata", source = "sessionData")
    @Mapping(target = "deviceName", source = "deviceInfo")
    @Mapping(target = "deviceType", ignore = true) // Set by service
    @Mapping(target = "location", ignore = true) // Set by service
    @Mapping(target = "status", ignore = true) // Set by service
    @Mapping(target = "createdAt", ignore = true) // Set by JPA
    @Mapping(target = "lastActivityAt", ignore = true) // Set by service
    @Mapping(target = "expiresAt", source = "timeoutMinutes", qualifiedByName = "calculateExpiryAsOffsetDateTime")
    @Mapping(target = "user", ignore = true) // Set by JPA
    UserSession toUserSession(SessionCreateReq request);

    // === Custom Mapping Methods ===

    /**
     * Convert OffsetDateTime to Instant
     */
    @Named("offsetDateTimeToInstant")
    default Instant offsetDateTimeToInstant(OffsetDateTime offsetDateTime) {
        return offsetDateTime != null ? offsetDateTime.toInstant() : null;
    }

    /**
     * Check if session is active
     */
    @Named("isActive")
    default Boolean isActive(UserSession session) {
        if (session == null) {
            return false;
        }
        // Check if status is ACTIVE and session hasn't expired
        return "ACTIVE".equals(session.getStatus()) &&
               session.getExpiresAt().isAfter(OffsetDateTime.now());
    }

    /**
     * Calculate session duration in minutes
     */
    @Named("calculateDuration")
    default Long calculateDuration(UserSession session) {
        if (session == null || session.getCreatedAt() == null) {
            return null;
        }

        OffsetDateTime endTime = session.getLastActivityAt() != null ?
            session.getLastActivityAt() :
            OffsetDateTime.now();

        return Duration.between(session.getCreatedAt(), endTime).toMinutes();
    }

    /**
     * Calculate expiry time from timeout minutes as OffsetDateTime
     */
    @Named("calculateExpiryAsOffsetDateTime")
    default OffsetDateTime calculateExpiryAsOffsetDateTime(Long timeoutMinutes) {
        if (timeoutMinutes == null) {
            timeoutMinutes = 1440L; // Default 24 hours
        }
        return OffsetDateTime.now().plusMinutes(timeoutMinutes);
    }

    /**
     * Calculate expiry time from timeout minutes
     */
    @Named("calculateExpiry")
    default Instant calculateExpiry(Long timeoutMinutes) {
        if (timeoutMinutes == null) {
            timeoutMinutes = 1440L; // Default 24 hours
        }
        return Instant.now().plusSeconds(timeoutMinutes * 60);
    }

    /**
     * Format Instant to readable string
     */
    @Named("formatInstant")
    default String formatInstant(Instant instant) {
        if (instant == null) {
            return null;
        }
        return DateTimeFormatter.ISO_INSTANT.format(instant);
    }

    /**
     * Format OffsetDateTime as Instant string
     */
    @Named("formatInstantFromOffsetDateTime")
    default String formatInstantFromOffsetDateTime(OffsetDateTime offsetDateTime) {
        if (offsetDateTime == null) {
            return null;
        }
        return DateTimeFormatter.ISO_INSTANT.format(offsetDateTime.toInstant());
    }

    /**
     * Build device info string from UserSession
     */
    @Named("buildDeviceInfo")
    default String buildDeviceInfo(UserSession session) {
        if (session == null) {
            return null;
        }
        return session.getDeviceName();
    }

    /**
     * Before mapping method for audit trail
     */
    @BeforeMapping
    default void beforeMapping(SessionCreateReq request, @MappingTarget UserSession session) {
        if (session != null) {
            session.setCreatedAt(OffsetDateTime.now());
            session.setLastActivityAt(OffsetDateTime.now());
            session.setStatus("ACTIVE");
        }
    }
}